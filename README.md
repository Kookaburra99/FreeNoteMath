# FreeNoteMath #

## General information ##

### Version details ###
Version: 1.0.0
Author: Pedro Gamallo FernÃ¡ndez
Release date: November 2020
Test compiler: gcc 6.3.0 20170516
Flex version: 2.6.1
Bison version: 3.0.4

### Abstract ###
FreeNoteMath (known simply as FNM) is a simply numerical computing enviroment that allows simply operations (+, -, *, /, % and ^), and calls to more complex computational functions (like trigonometric and exponential) including the corresponding math libraries. It also has a set of commands to regulate the work environment.

### Instalation ###
After donwloading the project, it must be compiled before being used. Inside *src* folder there is a *Makefile* to simplify this process:

```bash
cd src
make
```

This will generate all the compiled object files associated with all the source codes of the project, and an executable called ***FreeNoteMath***. To run it, no parameters are necessary:
```bash
./FreeNoteMath
# or
sh FreeNoteMath
```

*Makefile* provides a rule to remove all the compiled object files (but not the executable) to keep the directory clean:
```bash
make clean
```

To also delete the executable:
```bash
make cleanall
```

### Folder structure ###

- **examples**: Contains sample files with FreeNoteMath expressions and commands (*.fnm* extension, although the application accepts any other extension).  These files can be loaded with the *load* command to exemplify the use of the tool, or they can simply be read as a guide.

- **lib**: Contains libraries of functions and mathematical constants that can be used by the tool. For each library its source code (extension .c) and the shared compiled object (extension .so) are available. The latter can be included in the work environment through the *include* command. The source code files are only presented as a guide for the development of new libraries.

- **src**: Contains the source codes of the project (and its headers), as well as the Makefile for the compilation:
    - **commands.h**: Header file that defines the functions of the tool commands. It defines an external struct to contain the list of command functions, to be passed to the symbol table.
    - **commands.c**: Source file that implements the functions of the tool commands. It also fill the structure with the pointers to the declared functions.
    - **lexical.l**: File in *Flex* format that defines the input system and the lexical analyzer of the application. 
    - **lex.yy.h**: Header file that defines the main functions of the input system ant the lexical analyzer.
    - **lex.yy.c**: Source file that implements the functions of the input system ant the lexical analyzer. Generated by *Flex*.
    - **sintactic.y**: File in *Bison* format that defines the sintactic analyzer of the application.
    - **sintactic.tab.h**: Header file that defines the main functions, macros and global variables of the sintactic analyzer.
    - **sintactic.tab.c**: Source file that implements the functions of the sintactic analyzer. Generated by *Bison*.
    - **ST.h**: Header file that defines the structure that contains the stored information on the symbol table and its functions.
    - **ST.c**: Source file that implement the functions of the symbol table.
    - **main.c**: Main source file, that starts de execution of the aplication


## User manual ##

### The prompt ###
When starting the application, and after each evaluated line, the prompt is shown:
```bash
$> 
```

In it, any expression recognized by the tool can be entered, which will be evaluated after the corresponding carriage jump:
```bash
$> 3+3
    6
$> 4*6-2+3^2
    31
```

Valid expressions are: *Arithmetic operation*, *variable assigment*, *command* and *function call* (previously loaded by including the corresponding library). These can appear mixed with each other, except for the command that must always go on a single line.

### Arithmetic operation ###
The simple arimetic operators recognized by the tool are (ordered from lowest to highest precedence):
- Addition (+) and substraction (-).
- Multiplications (*), divisions (/) and modules (%).
- Unitary negation (-).
- Exponentiation (^).

This precedence can be altered by means of the parentheses, so that the expression within them is analyzed first.

### Variable assigment ###
The result of analyzing a mathematical expression can be stored in a variable. In *FreeNoteMath* variables don't need to be declared, but they must be previously initialized to be used in a new mathematical expression (otherwise, the tool will show a semantic error).

Assignments on the right side of a mathematical expression is not allowed, but several successive assignments can be chained together. For example:
```bash
$> a = b = c = 3+3
```

In the previous example, variables *a*, *b* and *c* are initialized, assigning them the value 6.

### Commands ###
There are a set of commands available to manage the work enviroment:
- **clear**: Deletes all the variables initialized in the workspace. It does not receive any parameters from the user.
- **echo**: Enables/Disables printing the value assigned in a variable assignment. By default, it's disable. Example:
```
$> a = 3+3
$> echo
** Enabling echo option for assigments... **
$> a = 3+3
    6
$> echo
** Disabling echo option for assigments... **
```
- **help**: Displays a help menu with the command list.
- **include("file")**: Loads functions and constants defined on a library. The parameter *file* must go inside double quotes and reference the path (relative or absolute) to the library's .so file. Example:
```
$> include("../lib/trigonometric.so")
Including functions...
	cos
	sin
	tan
	cosh
	sinh
	tanh
	acos
	asin
	atan
	acosh
	asinh
	atanh
Including constants...
	PI
** Library included succesfully! **
```
- **load("file")**: Loads an extern file and run all the expressions of this. The parameter *file* must go inside double quotes and reference the path (relative or absolute) to the extern file.
- **print("message")**: Prints on screen the message specified as a parameter in double quotes.
- **quit**: Finishes the execution of the program
- **workspace**: Shows all the initialized variables and loaded constants.

### Function libraries ###
By default, there are no mathematical functions defined. These can be loaded through the inclusion of the corresponding library (see *include* command, from the previous section).

Function libraries can be developed by the user following a series of guidelines:
- If you want to include functions in the library, an array of strings must be defined with the name *function_names*. This array must contain the names of the functions defined in the library and must end with the value 0:
```C
/** Functions names **/
const char* function_names[] = {
    ...,     
    0   /* Ends with 0 */
};
```

- If you want to include functions in the library, an array of pointer to functions with the name *function_ptr*. This array must contain the pointer to the functions defined in the library and must be end with the value 0. The returned value for the functions must be a double:
```C
/** Functions pointers **/
double (*function_ptr[])(double) = {
    ...,       
    0   /* Ends with 0 */
};

```

- If you want to include constant in the library, an array of strings must be defined with the name *const_names*. This array must contain the names of the constants defined in the library and must end with the value 0:
```C
/** Constants names **/
const char* const_names[] = {
    ...,     
    0   /* Ends with 0 */
};
```

- If you want to include constant in the library, an array of doubles must be defined with the name *const_values*. This array must contain the values of the constants defined in the library and must end with the value 0:
```C
/** Constants values **/
const char* const_values[] = {
    ...,     
    0   /* Ends with 0 */
};
```

The library must be compiled as an shared object to be used by the application:
```bash
gcc -lm -shared -o library_name.so -fPIC library_name.c
```